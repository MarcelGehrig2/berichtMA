% TODO: kapitel unterkapitel. merge mit zynq?

\chapter{Zybo}

% TODO: Text

\section{Floating Point Unit}
FPUs (\textit{Floating Point  Unit}) können je nach Implementation unterschiedliche Funktionen unterstützen.
In den Register MVFR0 und MVFR (\textit{Media and VFP Feature Register}) lässt sich auslesen, welche Funktionen effektiv in der Hardware implementiert wurden und genutzt werden können.
Diese Register können aber nicht mit einer einfachen \textit{Memory read} gelesen werden.
Um diese Register, oder die anderen speziellen FPU-Register wie FPSID, FPSCR und PFEXC, lesen zu können, muss der Assembler Befehl \textit{''VMRS''} verwendet werden.

\subsection{FPU initialisieren}
Damit auf die FPU zugegriffen werden kann, muss der Co-Prozessor 15 erst so konfiguriert werden, dass das System im \textit{secure} und im \textit{non-secure mode} Zugriff auf die FPU hat.
Der CP15 ist ein \textit{''System control coprocessor''} der neben der FPU auch den Cache und die MPU (Memory Protection Unit) konfiguriert.
Um in ein Register des Co-Prozessors schreiben zu können, muss eine spezielle Instruktion \texttt{''MCR''} verwendet werden, die ein ARM-Register in ein Co-Prozessor-Register speichert.
Da OpenOCD diese Instruktion unterstützt, können die \textit{Access Control Register} direkt mit dem Debugger gesetzt werden kann.

Das NSACR (\textit{Non-secure Access Control Register}) kontrolliert, ob die FPU auch im \textit{non-secure mode} genutzt werden kann.
Das CPACR (\textit{Coprocessor Access Control Register)} kontrolliert den Zugang zu allen Coprozessoren (CP10 und CP11 sind die FPU) abgesehen von CP14 und CP15.

Zusätzlich muss auch noch das FPEXC EN Bit im FPEXC Register (\textit{Floating-Point Satus and Control Register}) gesetzt werden.
Das FPEXC Register kann aber nicht mit dem Debugger direkt gesetzt werden, da eine spezielle ARM Instruktion dafür verwendet werden muss.
Im Kapitel \textit{''2.4.2 Accessing the FPU registers} des FPU-TRM\cite{bib:FPUTechnicalReferenceManual} sind die Details beschrieben, welche Register genau gesetzt werden müssen.

Mit dem folgenden ARM Code kann die FPU z.B. beim Booten des Kernels initialisiert werden:

\lstset{language=[x86masm]Assembler}
\begin{lstlisting}[frame=single]
; Set bits [11:10] of the NSACR for access to CP10 and CP11 from both Secure and Non-secure states:
MRC p15, 0, r0, c1, c1, 2
ORR r0, r0, #2_11<<10 ; enable fpu/neon
MCR p15, 0, r0, c1, c1, 2
; Set the CPACR for access to CP10 and CP11:
LDR r0, =(0xF << 20)
MCR p15, 0, r0, c1, c0, 2
; Set the FPEXC EN bit to enable the FPU:
MOV r3, #0x40000000
VMSR FPEXC, r3
\end{lstlisting}


\subsection{MVFR lesen mit OpenOCD}
OpenOCD kann zwar direkt die Register der generischen Co-Prozessoren lesen und schreiben, nicht aber die Register der FPU.
Der folgende Ablauf ermöglicht es aber trotzdem, diese Register auszulesen:

\begin{enumerate}
\item OpenOCD starten und für das CLI eine Telnetverbindung zu Port 4444 aufbauen
\item \texttt{reset init}\ \ \ \ \ \textcolor{darkgreen}{// Reset und Initialisierung des ganzen Systems.} 
\item \texttt{arm mcr 15 0 1 1 2 0x0c00}\ \ \ \ \ \textcolor{darkgreen}{// Non-secure access für FPU (NSACR Register).} 
\item \texttt{arm mcr 15 0 1 0 2 0x00f00000}\ \ \ \ \ \textcolor{darkgreen}{// Genereller Zugang für FPU erlauben (CPACR Register).} 
\item \texttt{mww 0x0 0xEEF70A10}\ \ \ \ \ \textcolor{darkgreen}{// Speichert die Instruktion \texttt{''VMRS R0, MVFR0''} in den OCM.}
\item \texttt{mww 0x4 0xEEF61A10}\ \ \ \ \ \textcolor{darkgreen}{// Speichert die Instruktion \texttt{''VMRS R1, MVFR1''} in den OCM.}
\item \texttt{bp 0x8 1 hw}\ \ \ \ \ \textcolor{darkgreen}{// Breakpoint nach der Instruktion (32 Bit Instruktion = 4 Byte)}
\item \texttt{resume 0x0}\ \ \ \ \ \textcolor{darkgreen}{// Führt die Instruktion bei der Adresse 0 aus}
\item \texttt{reg 0}\ \ \ \ \ \textcolor{darkgreen}{// Liest dass Register 0 aus, welches eine Kopie des MVFR0 enthält.}
\item \texttt{reg 1}\ \ \ \ \ \textcolor{darkgreen}{// Liest dass Register 1 aus, welches eine Kopie des MVFR1 enthält.}
\end{enumerate}

Die Inhalte der Register sind:
\begin{itemize}
\item MVFR0:	0x1011\_0222
\item MVFR1:	0x0111\_1111
\end{itemize}



\subsection{Unterstützte Features der FPU}
Die Register MVFR0 und MVFR1 enthalten Informationen über die unterstützten Features der FPU.
% TODO Seite XXX
Auf der Seite XXX des ARMv7-A ARM\cite{bib:ARMv7ArchitectureReferenceManual} (\textit{Architecture Reference Manual}) ist beschrieben, wie die unterstützten Features aus den Register gelesen  werden können.

Der Zynq 7000 des Zybo unterstützt:
\begin{itemize}
\item 
\end{itemize}





